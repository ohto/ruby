Instruction of vector processing for "SuperCon" (2015 year edition) MAKOTO Kikuchi (Cybermedia Center, Osaka University)

1. Introduction
Vector processing is to do the same calculation to each element of array in short.

For this reason, an object of interest is loop processing for array.

Scalar processor like PC
calculates even these problems sequentially one element after another.

On the other hand, vector processor calculates one element
without waiting for other element's calculation to end.

Put simply, it calculates each element almost simultaneously.

The CPU of NEC SX-ACE can calculate up to 256 elements at about the same time.

So,
the part where it takes match time to compute in the program
needs to be written
as the effective loop iteration suited the vector processing
in order to calculate at high speed.

The basic of vector processing will be explained below,
but fundamental policy for using vector processing successfully
comes down to writing simple loop iteration without surplus elaboration.


2. example of vectorization

For example,
a typical loop iteration for effective vector processing is as follows;


Previous code  
multiplies the elements of each array
and stores its results to another array.

And following code do
same calculation (but depend on loop variable) to each element of array,
and so forth.


these kind of calculations are
estimated automatically for the compiler
at vector processing,
and processed (almost) concurrently.

This operation is called auto vectorization by compiler.
A number of loop iteration time is named vector length.

Vector length of these cases described before is 1000.

the longer vector length,
the more effective calculate
(then shorter time required for each calculation)
in general.

Because 256 calculations are able to be executed concurrently by SX-ACE,
the calculation efficiency becomes high until 256 of vector length,
and maximum efficiency is kept more than 256.

On the contrary,
because the calculation time takes long
at too short loop (less than 5 vector length),
the code is not vectorized in this case.

the program should be written 
to be estimated easily for the compiler
that the code is able to be vectorized
in the case of writing by programming language C
as explained below.

In addition,
the vectorization is do (when meet the conditions)
not only for-loop but while and if-goto and such,
but for-loop would be used in most cases.


“assignment”
and the operations named “summation”, “multiplication” besides
ware used
in the loop of the examples described before,
but you may think that
almost of operations (such as +, -, *, /, %) in addition to these
are able to use.

even if
trinomial expression operator including condition judgement
((A)? B:C)
is able to be vectorized.

Bit operations
(such as logical summation (|), multiplication (&) for each bit)
are also able to be vectorized mostly without problem,

but it seems that
bit shift operations (<< and >>)
are not able to be vectorized
in the case
that the number of shift (right side of the operations) is valuable.

Well,
every kind of for-loop are not able to be vectorized of course.

The loop which is possible to vectorize
requires the independence of the calculation for each element.

Independence is that the
results of the calculations are not changed even if their orders are swapped.

As a matter of fact,
the calculations are tried to execute concurrently
even if these do sequentially on the program,
then these orders are different from the program in practice.

Then,
the loop process is required
that the results of the calculations are not changed.

It is founded at a glance
that the examples described before are suitable.

Because
the calculation in accordance with i=0 (a[0] = b[0] * c[0])
is not related completely
for example the result of of the calculation of i=100
(a[100] = b[100] * c[100]),

any number of
calculations which different variable of i
are able to execute concurrently,

then the results are same
when these calculations are executed sequentially.

This is the meaning of the independence.

The details are explained later
in “definition, reference relationship”.


Then, how about the following code?

It seems not to be able to vectorize
for changing the value of x along the loop processing
if calculation order is changed.

But 
because this process sums up the element values of the array a
from its index 0 to 999
to store the variable x,
the processed final value of x is the same
even if any calculation order is taken
after all.

This sort of loop processing is indeed vectorized accurately
by the compiler as sum up operation.

Of course,
multiplication operation is able to be done
instead of summation.

Typical patterns such as
processing of maximum and minimum values and so on
other than "sum up"
are able to be vectorized.

For example,
processing of minimum value is as follow code.


it seems not to be able to vectorized
for including "if" operation,
but
it is estimated
as the pattern of "processing of minimum value"
for the compiler.

xmin and imin values are shared
in each calculation of the loop processing
may be a problem;
however, 
it is able to be done.

Even though the general loop processing including "if"
is able to be vectorized,
but this case is described after.


The vectorized target of the loop processing
is able to be composed of many calculating sentences.

For exsample,
because the following code is
the combination of the
sentences which are able to be vectorized,
whole of this loop processing can be vectorized.

For comparison,
it is interpretated by the compiler in reality
as following code
and vectorized.

In fact,
calculate order is changed from the code.

This point is commited to your mind
because
it becomes the important hint
to consider
what type of the loop processing is able to be vectorized.

when
the sentence which cannot be vectorized
is in the loop processing,
only the sentences which can be vectorized
are done.


3. function

Most of all built in functions in libm are vectorized.

For example, the following code such like can be processed.


This code sums up
the distance of two points
(or rather length of the space vector)
in the plane.

Naturally,
next code for processing of the minimum distance
can be done.


but,
not every of the function call can be included,
so you may bear in mind that libm is special.

When the function defined by you is used
in the loop processing,
it is not vectorised.

in this case,
the process described in the functon
is inserted to the loop processing directly.

And the loop processing
includes input or output operation
is not able to be vectorised.


4. control valuable, element number

when the calculation using
element number of the array is shifted,
of course, it can be done.

For exsample, this code is vectorized safely.


To be sure,
control valuable of the loop processing
is allowed count up not only one by one.

The case of up by constant value such as 2 or 5,
or contrary the down case,
it can be done.

In this case,
the vector length is 
the number of the iteration of the operation
in reality.


The case of the element number is
caluculating formula using control valuable,
it can be done, for example is as follow.


Frequently used case is
that element number is decided by other array.

This case is called by "list vector",
for example is as follow.


Of course, needless to say
in order to satisfy the element numbers
are indicated by the values of ix and iy
(
the value of ix[100] is not allowed to be set 1000 or 10000
while element number is limited from 0 to 999
),
it should be desided in the program.


5. if

In order to calculate satisfyed the paticular conditions only,
"if" sentence is used.

It can be vectorized in this case,
but the computer in practice,
create the short array which is
collected the elements satisfyed the conditions
and execute it.

Then, this code is vectorized.


But in this case it can be described nomally as forllow.

It's better not to use "if" sentence
because processing time may be shorten
in case of it has not be used.


More complexed example such as
the processing described below to
count up the number of space vector
whose length is equal or longer than sertain value of r0
can be done.


of course,
the loop process which contains even if "else" or "else if"
can be done.

but the rule is exists
that when the loop processing
using "goto" operation after "if" condition clause,
the destination of the "goto" is required in the loop
and after this operation
(cannot back before the operation)
.

It's easy to understand
for reminding that
the calculation order is changed
when several sentences are included in the loop processing.

Then, the following code as like
can be vectorized.


But in this case it is clean described using "if...else"
and should be.


On the other hand,
only special type of
the "if" sentence which go out of the loop processing
is be vectorized.

Basically,
you should think
only the case 
to find the elements matching the sertain conditions.

Following code is this type.


6. multiple loop, mutidimentional array

In the case of multiple loop, basically,
the most inner loop processing is vectorized.

And the following codes are different in
the point of view of the calculation efficiency.


Mutidimentional array is allocated
the most right index in succession
on the memory of the computer
(a[i][1] and a[i][2] is next to each other).

on the oter hand,

when the left index is different by only one,
these valiables are allocated far places on the memory
(a[1][j] and a[2][j] is allocated far places each other).

Because
the caluculation efficiency is highter
from more contiguous address space of the memory as possible
when the values is retrieved,

second code which uses value j for inner loop
is faster than the first one
in this example.

In the same way,
the point to make the caluculation efficiency high
is also that
to become the vector length related right index
is as longer as possible.


the loop processing
made of even if the simple double loop calculation
can be vectorized in practice.

Then,
the compiler treats this processing
as one loop calculation whose length is 1000000.

But,
whole multiple loop processing is able to be vectorized
only in the simple case that
executed statements are in the most inner loop calculation.


Because the compiler is quite smart in reality,
the whole processing can be vectorized automatically
for swapping inner loop caluculation and outer one as like,
but,
variety of the condition exists
when the whole processing is vectorized.


7. definition, reference relationship

whether vectorization is able to or not is desided
by
definition and reference relationship
in the loop processing,
in other words,
the relation of the left side and the right side
of the assignment operation.

in the case that
the loop processing is consist of several sentences,
when the result of the calculation may be changed
for changing calculation order in accordance with the vectorization,
it is not be able to vectorized.

In these two codes,
because the first one is apparently different from the latter,
then the first one can not vectorized as it is.

The other two codes,
the first one is able to be vectorized
for the same meaning of these codes.


when the same valuables are used two times,
and the definition (left member of the assignment operation)
is used before the reference (right member),
the loop processing can be done.


As simple loop processing about this,
it might be vectorized by the compiler
for daring to swap the order of the sentences,
but you should consider that
it is basically not able to be vectorized in such a case.


So, in these two codes,
although it seems to that
the fast one is different from the latter,

the valiable of x is called work variable in this case,
estimated collectly by the compiler
only as temporary store in each loop calculation,
then it can be vectorized.


That the definition is before the reference
is important in this case too,
on the other hand,
the code with reverse condition
described below
is not vectorized.

Then, you should use work variables actively.
if you dare to use an array insted of these
the execution time becomes longer on the contrary.


above the exsample is revised a little to following code
(element number i is changed by 2),
it can be vectorized
for resolving the problem of
the definition and the reference relationship.


Because this code is the same as following.

The result of the processing is free from
the changing of the calculation order,
for
the element indicated odd index of the array a is the definition,
and the element indicated even index is the reference.


By the way,
the case of that
the different elements in the same array
are used both sides in the sentence
seems to be able to be vectorized
(do in reality),
the contrary case described below
seems not to be vectorized.


But,
it is vectorized too
for special pattern called recursion formula
(
not only multiplication
but summation and subtraction
are done
).


8. indication of the vectorization line

It seems to be the same loop processing at a glance,

The definition and the reference relation
is suitable for the vectorization or not
at the subtle difference in appearance
(
but big difference is exist for the processing
).



This difference should be treated by the compiler collectly,
but it is failed in the cases.

When using list vector is one of this cases.

For example, the code described below,
althouth this loop processing can be vectorized in fact,
it isn't estimated by the compiler.

In this case,
you should need to teach to the compiler to be vectorized if possible
using
special operation called indication of the vectorization line.


For the above case,
the code is described below.

The part written with "#pragma vdir nodep" is
the indication of the vectorization line.


It indicates to the compiler
that the definition and the reference relation is
suitable for vecorization collectly
in the following loop processing.

"nodep" is the abridgment of "no dependence".


The variety of the indication of the vectorization line exists.
but this "nodep" uses in the most cases.

Probably,
you might know only this
in the SuperCon.

Furthermore,
the variety of the indication of the vectorization line
is not a part of the programming language of C.

"nodep" uses in this case
is also
the original instruction of SX-ACE.

Because "#pragma" is for describing
the specific instruction at each processing system,


When the code included this instruction
is compiled using gcc of LINUX,
the instruction is ignored and
the code is not affected.


9. function

the method of the sending the array to the function
is basically the same as nomal situation.


The number of the iteration of the loop processing is
the parameter
and if it is not determined at compilation phase,
it is not the problem.


But,
because
automatic vectorization goes fail
if the definition and the reference relation is not understandable
by the compiler,
you might not use pointer elabotately.


Although it is not neat for programming,
the array described as the grobal variable
is also a case for the simple and certain actually.

and,
it may be vectorized collectly
when list vector is used.


Because for many cases,
the definition and the reference relation is not be understood
for the compiler in the function,
you should use "#pragma vdir nodep" properly.


10. parallelization

The consept of parallelization is different from
the vectorization.


Vectorization is for
execution at the special computing unit
for the part of the loop caluculations,

otherwise,
parallelization is for
deviding the processing 
to multiple CPUs and executing each.


parallelization is
wider for what is possible
and easier to apply,

otherwise,
if the loop processing is able to be vectorized,
the calculation efficiency is higher.

SX-ACE is one of the vector parallel computers
consisted that more than one CPU having vector computing units
is connected


It would be a shame to put such a good opportunity to waste,
so let's apply the function of the parallelization.

Although
complex parallelization can be described at SX-ACE
if the instruction is in detail,
automatic parallelization is only used
in this time.

Even this limit,
it is parallelized quite smartly.

Option "-Pauto" is indicated
at compile phase
for automatic parallelization.

Mainly,
parallelization part is the outer loop process of the multiple loop.

This process is devided to several parts,
sent to each CPU and executed.

Of cource,
the loop process which can be parallelized is limited
for not changing its result.

Unlike the vectorization,
the whole of the CPU time is not decreased
for parallelization.

What is even worse,
the CPU time is rather increased
for the extra operation
of the parallelization process.

But,
the actual time is decreased
for these processes
are executed in parallel.


Because
SX-ACE is consist of four CPUs per one node,
parallel processing can be executed
using 4 CPUs in maximum.

Authough
more large scale of
parallel processing can be executed
for using amount of the node,
parallelism is limited upto four in SuperCon.

Even this limit,
when the program which is easy to parallelize is made,
the computing time can be decreased to 1/4.

To pay attention is that
parallelization is realized by the function.


the target for the parallelization
is whole of the function including the
other parts of the loop process
which executed by parallel.

The complete same calculation is executed
in all of the CPUs
except for the loop process.

Because,
the sentences in one function
are separated to several functions
and
only the parts which is able to be parallelized
are tried to be parallelized,
the excessive strange things might not be happened.

In this process,
The result should be checked
because the amount of the parts depend on the compiler.


The other of the important reminder is
increasing in the memory usage
for parallelization.

Especially,
because
the array described in the function local
is copied to the number of the parallel processing,
memory usage is incleased explosively
in some cases.

On the other side,
that situation is not happened
at the case of using for the global variable,
and the same memory is shared by each CPU.


Then,
it is recommended
that massive amount of array data is allocated in global.

But,
it seems not so problematic
in the challenge of SuperCon.


11. Conclusion

it seem to be confused in may points
for vectorizing and parallelizing
being familiar with the programming at PC.


the basic
that
the algorithm whose less amount of caluculation
should be devised for efficient processing
is not changed.


Although
writing in the same programming language C,
the program which is well written of tuning for PC
is not performed for the vector computer.


Simple and gentle program is suited
for making good use of the vectorization
rather than
elaborate program like
using the essence of the language C.


For example,
recursive programming seems least to work.
(
of course,
although the program can be executed
only not vectorised,
calculatin effecency is not expected
).

And
the large array using malloc in PC
can be used without concern.


Saving the memory usage seems almost never required.

It is recommended that
the programming style
to allocate the large array
and iterete the large loop simply.


Please feel that
the considerably difference
of how to write the speedy program
for between PC and vector computer
on this opportunity.


